
Read  Bit Manipulation from CP Agorithms (excellent this mostly derived from there only)

0) 100 ~ 00000100  (we can do this to fill all the bits of the type we are using  with leading zeroes )
1) Bits are indexed in 0 Based Indexing from right in left . So any text saying ith bit (it is in 0 based system)  Eg  bk.....b2b1b0  where each bit place has a value associated = 2^k.
2)  2^k : {
            - has the kth bit set from right (0 based indexing) , (kth bitn in 0 based indexing  has value 2^k) or,
            - has the (k+1)th bit set from right (1 based indeixing ), (kth bit  in 1 based indexing has value 2^(k+1-1)=2^k)
    }
    2^k-1 : {
            - has all the bits  are set from 0th bit to k-1 th bit (i.e. first k bits are set (fundamental counting is always 1 based),
              while in contrast first k bits of 2^k is off and k+1 th bit is set)
    }


3)  FUNDAMENTAL CONCEPTS REGARDING EACH OPERATOR:
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
         AND(&) : - bitwise AND compares each bit of its first operand with the corresponding bit of its second operand. 
                    If both bits are 1, the corresponding result bit is set to 1. Otherwise, the corresponding result bit is set to 0.

 a)  _ & 1 = 1st Bit (***) {fetches the first bit}  { x&1 gives only 1 or 0 based on the 0th bit of x} 

  eg  0 & 1 = 0
      1 & 1 = 1
b)  _ & 0 = 0 (**) {Clearing the bit}
     
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
          OR (|) : - bitwise inclusive OR operator compares each bit of its first operand with the corresponding bit of its second operand. 
                     If one of the two bits is 1, the corresponding result bit is set to 1. Otherwise, the corresponding result bit is set to 0.

  a) _ | 0 = 1st Bit (***) {fetces the first bit}  { x|0 gives x always}

  eg  0 | 0 = 0
      1 | 0 = 1

  b) _ | 1 = 1 (**)   {Setting the bit}

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
          XOR (^) : - exclusive OR (XOR) operator compares each bit of its first operand with the corresponding bit of its second operand. 
                      If one bit is 0 and the other bit is 1, the corresponding result bit is set to 1. Otherwise, the corresponding result bit is set to 0.

     _ ^ 1 = ~1st Bit {Flips the first Bit}

  eg  0 ^ 1 = ~0=1
      1 & 1 = ~1=0
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
      RIGHT SHIFT (>>) : - Shifts a number to the right by removing the last few binary digits of the number. 
                           Each shift by one represents an integer division by 2, so a right shift by k represents an integer division by  2^k .
       x>>k = ⌊x/2^k⌋
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
      LEFT SHIFT (<<) : - Shifts a number to left by appending zero digits. In similar fashion to a right shift by  k , a left shift by k  represents
                          a multiplication by 2^k .
       x>>k = x*2^k
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------4) AND Use-Case and Concepts:-
4) USEFUL TRICKS:_

    a}Set/flip/clear a bit:-
            - (1 << x) is a number with only the  x-th bit (0 based indexing) set, while  ~(1 << x )  is a number with all bits set except the x-th bit.
                        EXPLAINATION : {1 is a no. whose 0th bit is set so 1<<1 , jump =1 is a no. whose 1st bit is set (0 based)} 

            i) n | (1<<x) : sets the xth bit in the no. n . {Explaination : (1<<x) has only xth bit set and then using fundamental concept of OR}
           ii) n ^ (1<<x) : flips the xth bit in the no. n. {Explaination : (1<<x) has only xth bit set and then using fundamental concept of XOR }
          iii) n & ~(1<<x) : clear the x th bit in the no. n. {Explaination : ~(1<<x) has only xth bit of and then using fundamental concept of AND ; all the bits except x-th bit are unchanged when & with 1 and the x-th bit is cleared when & with 0}



5) CHECK IS A BIT IS SET OR NOT

            The value of the x-th bit can be checked by shifting the number x positions to the right, so that the 
            x-th bit is at the unit place, after which we can extract it by performing a bitwise & with 1. (fundamental property of AND)

    IMPLEMENTATION:-
    bool is_set(unsigned int number, int x) {
         return (number >> x) & 1;
    }

5a) Checking if the 0th or UNIT bit is set or not hence determinig odd/even repectively

     (x&1) = {
                  1, if x is odd
                  0 , if x is even
        }

        Proof:- 

        Using the fundamental concepts of AND

        Facts: If x is even its last bit is off eg 1 : 0001  eg 15 : 1111 (last bit set)
               If x is odd its last bit is on.  eg 2 : 0010  eg 16 :10000 (last bit off)

        so just referring the fundamental concept of AND 
        x&1  makes the last bit of the ans dependent on the last bit of x and all other bits of the ans is zero . So the ans is 1 if last bit of x is set (when x is odd)
              else the ans is 0 if last bit of x is off  (x is even)
        eg  x = 15 =  1111
                &1 =  0001
              -------------
                      0001 -> 1 -> x is odd
        eg x = 16 = 10000
               &1 = 00001
              -------------
                    00000->0-> x is even




6) CHECK IF A NUMBER IS DIVISIBLE BY A POWER OF 2 or NOT
       Using the and operation, we can check if a number  n  is even because n&1 = 1 if n is odd and n&1 = 0 if n is even.
       More generally, n is divisible by 2^k exacly when n&(2^k-1) = 0 


     We can calculate  $2^{k}$  by left shifting 1 by  $k$  positions. The trick works, because  $2^k - 1$  is a number that consists of exactly  $k$  ones. And a number that is divisible by  
$2^k$  must have zero digits in those places.
      b} More Generally (innfering from a) x is divisible by 2^k exacly when x & (2^k-1) = 0.

        Proof:-

    
